package org.data2semantics.platform.reporting;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.data2semantics.platform.core.Module;
import org.data2semantics.platform.core.Workflow;
import org.data2semantics.platform.core.Workflow.WorkflowBuilder;
import org.openrdf.model.Model;
import org.openrdf.model.Resource;
import org.openrdf.model.Statement;
import org.openrdf.model.Value;
import org.openrdf.model.vocabulary.RDF;
import org.openrdf.query.BindingSet;
import org.openrdf.query.MalformedQueryException;
import org.openrdf.query.QueryEvaluationException;
import org.openrdf.query.QueryLanguage;
import org.openrdf.query.TupleQuery;
import org.openrdf.query.TupleQueryResult;
import org.openrdf.repository.Repository;
import org.openrdf.repository.RepositoryConnection;
import org.openrdf.repository.RepositoryException;
import org.openrdf.repository.sail.SailRepository;
import org.openrdf.sail.memory.MemoryStore;


/**
 * Extracting table from PROV, experimenting simplest case
 * @author wibisono
 *
 */
public class ExtractTable {

	Model statements;
	Repository repository;
	
	public ExtractTable(Model statements) {
		this.statements = statements;
		repository = new SailRepository(new MemoryStore());
		
		try {
			repository.initialize();
			
		} catch (RepositoryException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
	}

	/**
	 * @return
	 */
	public void  testPrintPROVStatements(){
		
		
		
		//Extract workflow based on the PROV statements.
		//Each activity corresponds to module instances.
		
		// Missing information about which modules are there in the workflow, since only instances is created as activity.
		
		Model activities = statements.filter(null, RDF.TYPE, PROVReporter.acURI);
		
		Set<Resource> sbjActivities = activities.subjects();
		
		
		//From these activities later we will need to extract input/output entities,
		for(Resource sActivity : sbjActivities){
			
			// Inputs which are used by current activity
			Model curInputs  = statements.filter(sActivity, PROVReporter.usedURI, null);
			
			// Outputs which are generated by current activity
			Model curOutputs = statements.filter(null, PROVReporter.wgbURI, sActivity);
			
			System.out.printf("Activity " +sActivity + " has %d inputs and %d outputs \n", curInputs.size(), curOutputs.size());
			
			System.out.println("Inputs : ");
			for(Value v : curInputs.objects()){
				Model val = statements.filter((Resource)v, PROVReporter.valueURI, null);
				System.out.print("\t "+v+ " : " );
				for(Value vv : val.objects()){
					System.out.print("  "+vv);
				}
				System.out.println();
				
			}
			
			System.out.println("Outputs : ");
			for(Resource r : curOutputs.subjects()){
				Model val = statements.filter(r, PROVReporter.valueURI, null);
				System.out.println("\t"+r+ " " );
				for(Value vv : val.objects()){
					System.out.print("  "+vv);
				}

				System.out.println();
			}
			
				
		}
	
	}
	
	public ValuesTable<Value> extractTable(TableSpecification spec) throws RepositoryException, MalformedQueryException, QueryEvaluationException{
		List<Value> result = new ArrayList<Value>();
		RepositoryConnection conn = repository.getConnection();
		
		Iterator<Statement> statIterator = statements.iterator();
		while(statIterator.hasNext()){
			conn.add(statIterator.next());
		}
		
		// Select row, col which produce value.
		// Simplest case http://yuml.me/27884f62
		
		// See what's missing here is the type of input, and the type of output.
		// Also what I got here now is actually only the URI of row, col, and out. while you care about value.
		String simpleTableQuery = 
				"\n	PREFIX prov: <http://www.w3.org/ns/prov#> " +
				"\n	PREFIX d2s:  <http://www.data2semantics.org/d2s-platform/>" +
				"\n	SELECT  ?vRow ?vCol ?vOut" +
				"\n	WHERE { " +
				"\n		?out 		rdf:type prov:Entity				." +
				"\n		?row 		rdf:type prov:Entity				." +
				"\n		?activity 	rdf:type prov:Activity 				." +
				"\n		?col 		rdf:type prov:Entity				." +
					
				"\n		FILTER (?row != ?col)							." +
				
				"\n		?out		prov:wasGeneratedBy		?activity	." +
				"\n		?activity 	prov:used	?row					." +
				"\n		?activity	prov:used	?col					." +
				
				"\n		?row		<http://www.data2semantics.org/d2s-platform/value>  ?vRow					." +
				"\n		?col		<http://www.data2semantics.org/d2s-platform/value>	?vCol					." +
				"\n		?out		<http://www.data2semantics.org/d2s-platform/value>	?vOut					." +
				
				"\n		?activity   rdfs:label 			?activityLabel . " +
				"\n		FILTER 		regex(str(?activityLabel), \"" + spec.getModuleName() + "\", \"i\")	." +

				"\n		?out		rdfs:label		?outLabel													." +	
				"\n		FILTER		regex(str(?outLabel), \""+spec.getOutputName()+"\",\"i\")"+	
				
				"\n		?row		rdfs:label		?rowLabel													." +	
				"\n		FILTER		regex(str(?rowLabel), \""+spec.getRowInputName()+"\",\"i\")"+	

				"\n		?col		rdfs:label		?colLabel													." +	
				"\n		FILTER		regex(str(?colLabel), \""+spec.getColInputName()+"\",\"i\")"+	

				"\n	}" ;

				
		System.out.println(simpleTableQuery);
		TupleQuery tableQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, simpleTableQuery);
		
		TupleQueryResult qResult = tableQuery.evaluate();
		
		
		ValuesTable <Value> resultTable = new ValuesTable<Value> (); 
		while(qResult.hasNext()){
			BindingSet cur = qResult.next();
			Value vRow = cur.getValue("vRow");
			Value vCol = cur.getValue("vCol");
			Value vOut = cur.getValue("vOut");
			
			System.out.println(vRow +","+vCol+","+vOut + " ");
			resultTable.add(vRow,vCol,vOut);
		}
		
		Set<Value> uniqueRows = resultTable.uniqueRows();
		Set<Value> uniqueCols = resultTable.uniqueCols();
		System.out.println(uniqueRows);
		
		System.out.println(uniqueCols);
		
		for(Value r : uniqueRows){
			System.out.println();
			for(Value c : uniqueCols){
				System.out.print(resultTable.getValue(r, c)+"  ");
			}
		}
		
		return resultTable;
	}
 }
